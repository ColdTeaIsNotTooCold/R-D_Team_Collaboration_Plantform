# 代理系统

专门执行繁重工作并返回简洁摘要以保持上下文的专业代理。

## 核心理念

> "不要将子代理拟人化。用它们来组织你的提示并省略上下文。子代理的最佳状态是能够执行大量工作，然后仅向主对话线程返回少量信息。"
>
> – Adam Wolff, Anthropic

## 可用代理

### 🔍 `code-analyzer`（代码分析器）
- **用途**：跨多个文件查找错误，不污染主上下文
- **模式**：搜索多个文件 → 分析代码 → 返回错误报告
- **使用场景**：需要追踪逻辑流程、查找错误或验证更改时
- **返回**：仅包含关键发现的简洁错误报告

### 📄 `file-analyzer`（文件分析器）
- **用途**：读取和总结冗长文件（日志、输出、配置）
- **模式**：读取文件 → 提取洞察 → 返回摘要
- **使用场景**：需要理解日志文件或分析冗长输出时
- **返回**：关键发现和可操作的洞察（减少 80-90% 的内容）

### 🧪 `test-runner`（测试运行器）
- **用途**：执行测试，不向主线程转储输出
- **模式**：运行测试 → 捕获到日志 → 分析结果 → 返回摘要
- **使用场景**：需要运行测试并理解失败原因时
- **返回**：带有失败分析的测试结果摘要

### 🔀 `parallel-worker`（并行工作器）
- **用途**：协调一个问题的多个并行工作流
- **模式**：读取分析 → 生成子代理 → 整合结果 → 返回摘要
- **使用场景**：在工作树中执行并行工作流时
- **返回**：所有并行工作的整合状态

## 为什么需要代理？

代理是**上下文防火墙**，保护主对话免受信息过载的影响：

```
无代理情况：
主线程读取 10 个文件 → 上下文爆炸 → 失去连贯性

有代理情况：
代理读取 10 个文件 → 主线程获得 1 个摘要 → 上下文保持
```

## 代理如何保持上下文

1. **繁重工作** - 代理执行混乱的工作（读取文件、运行测试、实现功能）
2. **上下文隔离** - 实现细节保留在代理中，不在主线程中
3. **简洁返回** - 仅基本信息返回到主对话
4. **并行执行** - 多个代理可以同时工作，不会发生上下文冲突

## 使用示例

```bash
# 分析代码错误
任务："在代码库中搜索内存泄漏"
代理：code-analyzer
返回："发现 3 个潜在泄漏：[简洁列表]"
主线程永远不会看到：检查的数百个文件

# 运行测试
任务："运行身份验证测试"
代理：test-runner
返回："2/10 测试失败：[失败摘要]"
主线程永远不会看到：详细的测试输出和日志

# 并行实现
任务："用并行流实现问题 #1234"
代理：parallel-worker
返回："完成 4/4 流，修改了 15 个文件"
主线程永远不会看到：单个实现细节
```

## 创建新代理

新代理应遵循以下原则：

1. **单一用途** - 每个代理都有一个明确的工作
2. **上下文减少** - 返回处理内容的 10-20%
3. **无角色扮演** - 代理不是"专家"，它们是任务执行者
4. **清晰模式** - 定义输入 → 处理 → 输出模式
5. **错误处理** - 优雅地处理失败并清晰报告

## 避免的反模式

❌ **创建"专家"代理**（数据库专家、API 专家）
   代理没有不同的知识 - 它们都是同一个模型

❌ **返回冗长输出**
   违背了上下文保持的目的

❌ **让代理相互通信**
   改用协调器代理（如 parallel-worker）

❌ **为简单任务使用代理**
   仅在上下文减少有价值时使用代理

## 与 PM 系统集成

代理与 PM 命令系统无缝集成：

- `/pm:issue-analyze` → 识别工作流
- `/pm:issue-start` → 生成 parallel-worker 代理
- parallel-worker → 生成多个子代理
- 子代理 → 在工作树中并行工作
- 结果 → 整合回主线程

这创建了一个层次结构，在每一层都最大化并行性同时保持上下文。
